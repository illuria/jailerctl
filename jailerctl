#!/bin/sh

# set global variables
PROGNAME=${0##*/}
VERSION="0.1.0"

COLOUR_SET_R="\033[0;31m"
COLOUR_SET_G="\033[0;32m"
COLOUR_SET_Y="\033[0;33m"
COLOUR_SET_B="\033[0;34m"
COLOUR_SET_M="\033[0;35m"
COLOUR_SET_C="\033[0;36m"
COLOUR_SET_W="\033[0;37m"
COLOUR_END="\033[0m"

help_usage(){
  cat <<EOT
Usage: jailerctl ...
  help
  version
  remote
    list
    add    RemoteName username@host [sudo]
    remove RemoteName
    rename RemoteName NewRemoteName
  list
    [Remote]
  inspect [Remote]
  run Remote <jailer command>
EOT
  exit 0
}

help_version(){
  printf "%s: v%s\n" "${PROGNAME}" "${VERSION}"
}

help_tbd(){
  printf "This feature is not implemented yet...\n"
}

remote_list(){
  _remotes=$(ls ~/.jailerctl/remotes/)
  [ -z "${_remotes}" ] && echo "No remotes available. Use \`${PROGNAME} remote add\` to add remotes" && exit 0
  for remote in ${_remotes} ;
  do
    printf "${remote}^"
    cat ~/.jailerctl/remotes/${remote}
  done | column -ts^
}

remote_add(){
  shift
  [ "$#" -lt 2 ] && help_usage
  _remoteName="$1"
  _remoteConn="$2"
  _remoteSudo="$3"

  [ -f ~/.jailerctl/remotes/$_remoteName ] \
    && printf "${COLOUR_SET_Y}WARN:${COLOUR_END} " \
    && printf "Remote ${_remoteName} already exists\n" \
    && exit 1

  ( echo "${_remoteConn} ${_remoteSudo}" >> ~/.jailerctl/remotes/$_remoteName ) \
    && printf "${COLOUR_SET_G}Done!${COLOUR_END}\n"
}

remote_remove(){
  shift
  [ ! "$#" -eq 1 ] && help_usage
  _remoteName="$1"

  [ ! -f ~/.jailerctl/remotes/$_remoteName ] \
    && printf "${COLOUR_SET_Y}WARN:${COLOUR_END} " \
    && printf "Remote ${_remoteName} doesn't exists...\n" \
    && exit 1

  ( rm ~/.jailerctl/remotes/$_remoteName ) \
    && printf "${COLOUR_SET_G}Done!${COLOUR_END}\n"
}

remote_rename(){
  help_tbd
}

remote_parse(){
  shift
  [ $# -eq 0 ] && remote_list
  case "$1" in
    list)   remote_list   "$@" ;;
    add)    remote_add    "$@" ;;
    remove) remote_remove "$@" ;;
    rename) remote_rename "$@" ;;
  esac
}

list_parse(){
  shift
  [ "$#" -eq 1 ] && list_do "$1" | sed -e '1s/^/HOST NAME STATE JID HOSTNAME IPv4 GW\n/'| column -t && exit 0
  _remotes=$(ls ~/.jailerctl/remotes/)
  for remote in ${_remotes} ;
  do
    list_do "$remote"
  done | sed -e '1s/^/HOST NAME STATE JID HOSTNAME IPv4 GW\n/'| column -t
}

list_do(){
  remoteName="$1"
  ssh -q -o ControlPersist=300 -o ControlMaster=yes -o ControlPath=/tmp/jailerctl.${remoteName}.ctl $(cat ~/.jailerctl/remotes/${remoteName}) jailer list | sed -e "1d" -e "s/^/${remoteName} /"
}

run_parse(){
  shift
  [ "$#" -lt 2 ] && help_usage

  _remoteName="$1"
  [ ! -f ~/.jailerctl/remotes/$_remoteName ] \
    && printf "${COLOUR_SET_Y}WARN:${COLOUR_END} " \
    && printf "Remote ${_remoteName} doesn't exists...\n" \
    && exit 1

  run_do "$@"
}

run_do(){
  remoteName="$1"
  shift
  jailerRun=$*
  ssh -q -o ControlPersist=300 -o ControlMaster=yes -o ControlPath=/tmp/jailerctl.${remoteName}.ctl -t $(cat ~/.jailerctl/remotes/${remoteName}) jailer "${jailerRun}"
}

inspect_parse(){
  shift
  [ ! -z "$1" ] && inspect_do "$1" && exit 0

  _remotes=$(ls ~/.jailerctl/remotes/)
  for remote in ${_remotes} ;
  do
    printf "$remote ->\n"
    inspect_do "$remote"
  done

}

inspect_do(){
  remoteName="$1"

  [ ! -f ~/.jailerctl/remotes/$remoteName ] \
    && printf "${COLOUR_SET_Y}WARN:${COLOUR_END} " \
    && printf "Remote ${remoteName} doesn't exists...\n" \
    && exit 1

  ssh -q -o ControlPersist=300 -o ControlMaster=yes -o ControlPath=/tmp/jailerctl.${remoteName}.ctl -t $(cat ~/.jailerctl/remotes/${remoteName} | cut -w -f 1) '/bin/sh -s' <<EOS
printf "  Hostname   : "
hostname
printf "  OS Version : "
freebsd-version
printf "  CPUs       : "
sysctl -n hw.ncpu
printf "  Load       : "
top -b | grep '^CPU:' | cut -w -f 2- | tr '\t' ' '
printf "  Memory     : "
top -b | grep '^Mem:' | cut -w -f 2- | tr '\t' ' '

jailer_zfs=\$(sysrc -n jailer_dir | cut -d : -f 2)
jailer_pool=\$(printf "\${jailer_zfs}" | cut -d / -f 1)
used=\$(zfs get -H -o value used \${jailer_zfs})
mountpoint=\$(zfs get -H -o value mountpoint \${jailer_zfs})
size=\$(zfs get -H -o value quota \${jailer_zfs})
[ "\$size" = "none" ] && size=\$(zpool get -H -o value size \${jailer_pool})
printf "  Jailer Dir : "
printf "\${used}/\${size} @ \${mountpoint}\n"

printf "  Jails      : "
jls jid | wc -l | cut -w -f 2
EOS
}

jailerctl_main(){
  [ $# -eq 0 ] && help_usage

  [ ! -d ~/.jailerctl ] && echo "Creating ~/.jailerctl" && mkdir -p ~/.jailerctl/remotes

  case "$1" in
    help)       help_usage         ;;
    version)    help_version       ;;
    remote)     remote_parse  "$@" ;;
    list)       list_parse    "$@" ;;
    run)        run_parse     "$@" ;;
    inspect)    inspect_parse "$@" ;;
    *)          help_usage         ;;
  esac
}

jailerctl_main "$@"
